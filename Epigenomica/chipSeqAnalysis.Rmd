---
title: "Chip-Seq: Pruebas para la anotación de ficheros bed"
author: "Diego Mañanes Cayero´"
date: "7/3/2020"
output: 
  word_document:
    toc: yes
    toc_depth: '3'
  pdf_document:
    fig_caption: yes
    keep_tex: yes
    number_sections: yes
    toc: yes
    toc_depth: 3
  html_document:
    collapsed: no
    number_sections: yes
    self_contained: no
    toc: yes
    toc_depth: 5
    toc_float: yes
geometry: margin=1in
header-includes:
- \usepackage{graphicx}
- \usepackage{float}
- \usepackage{pdflscape}
- \newcommand{\blandscape}{\begin{landscape}}
- \newcommand{\elandscape}{\end{landscape}}
fontsize: 11pt
classoption: a4paper
urlcolor: blue
---

```{r setup, include=FALSE}
## directories and paths
projectPath <- file.path("/home/diego/Documentos/proyectos_master/proyectos_transcriptomica/Transcriptomics/Epigenomica/")

analysisDir <- "chipSeq.Analysis"
analysisPath <- file.path("/home/diego/Documentos/proyectos_master/proyectos_transcriptomica/trabajo_transcriptomica/", analysisDir)
outputDir <- "FirstTest"
outputPath <- file.path(analysisPath, outputDir)
dataPath <- file.path(projectPath, "data")
prefix <- "FirstTest"
setwd(analysisPath)

if (!dir.exists(outputPath) | !dir.exists(file.path(outputPath, "Plots"))) {
  dir.create(outputPath, recursive = T)
  dir.create(file.path(outputPath, "Plots"), showWarnings = F)
}

## helper functions
# source(file.path(projectPath, "helperFunctions.R"))

## Settings to knitr
knitr::opts_chunk$set(
    fig.align = "center",
    fig.path = file.path(outputPath, "Plots/"),
    fig.pos = "H",
    message = FALSE,
    warning = FALSE,
    comment = NA,
    dev = c("jpeg", "svg"),
    dpi = 300
)

options(stringsAsFactors = FALSE)

## packages used
library(dplyr)
library(ChIPpeakAnno)
library(annotatr)
library(ChIPseeker)
library(clusterProfiler)
## desinstalar, ocupa medio giga xd
library(ReactomePA)
# library(TxDb.Hsapiens.UCSC.hg19.knownGene)
```

# Introducción

Análisis trabajo de CHiP-seq. Este documento consiste en algunas anotaciones 
con respecto a ChromeHMM y sobre algunos de los anotadores más relevantes en 
Bioconductor. Además, voy a meter cosas interesantes respecto al paper de 
Enrique y que podrían ser de utilidad. 


# ChromHMM: algunas consideraciones

**Link:**
<https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5945550/pdf/nihms963922.pdf>

## Introducción: por qué estudiar estados de cromatina

Mapear marcas epigenómicas permite anotar nuevos genes, identificar regiones
reguladoras y estudiar los cambios de actividad entre diferentes tipos célulares. 
Pueden estudiarse marcas individiales de forma aislada, ya sea a travñes de la
agregación de sus señales a través de todo el genoma en relación con 
un set de anotaciones predeterminadas como sitios de inicio de transcripción, 
límites de un exón, etc. O mediante el descubrimiento de estrechos picos o 
dominios más amplios donde esa marca está presente en mayor frecuencia que
en las regiones de alrededor. Sin embargo, se puede ganar información adicional 
mediante la combinación de múltiples marcas en su contexto espacial. Estos 
patrones, llamados "estados de cromatina", normalmente capturan clases conocidas 
de elementos genómicos como promotores, enhancers, tránscritos, represores y 
regiones repetitivas, aunque pueden capturar clases nuevas de subclases de 
elementos. El reconocimiento de estados de cromatina y la identificación de sus
ocurrencias genómicas en cada tipo celular provee una anotación sistemática de los
elementos de DNA y regiones reguladoras a lo largo de tipos celulares  que
pueden ser utilizadas para estudiar otros análisis como RNAseq, etc. 

## Fundamento ChromHMM

Consiste en un modelo generativo de machine learning que infiere los estados 
ocultos de cromatina a partir de las marcas epigenómicas vistas en cada posición 
de un determinado tipo celular. Estos estados ocultos de cromatina se conocen 
como "estados de cromatina", un término que trata de capturar la naturaleza 
probabilística de un modelo multiestado y la naturaleza biológica de un estado de
cromatina en esa posición. Para ello, utiliza HMM, ya que permiten el modelar
probabilísticamente las diferentes combinaciones de presencia y ausencia de 
múltiples marcas (en los parámetros de emsión) y las restricciones espaciales 
de cómo las combinaciones de esas marcas ocurren en relación a otras a través del 
genoma (en la matriz de transición: probabilidad de pasar de un estado a otro).

Las probabilidades de emsión de cada marca en el vector de probabilidades de
cada estado representan la probabilidad con la que cada marca es encontrada 
en ese estado. Las dependencias entre marcas son capturadas mediante diferentes
estados de cromatina, pero en cada estado, las probabilidades de emisión son
asumidas como independientes. Las probabilidades de transición de un estado a 
otro permiten al modelo capturar los sesgos posicionales de unos estados de 
cromatina con otros, como amplios dominios activos o reprimidos. Los parámetros
del modelo son aprendido de los dato _de novo_ mediante un procedimiento de 
ML no supervisado que iterativamente trata de maximizar el ajuste del modelo
a los datos. 

ChromHMM permite aprender los estados de cormatina, anotar sus concurrencias 
a lo largo del genoma y facilitar una interpretación biológica de los estados 
mediante la anotación de dichas posiciones. Ya que las modificaciones de histonas
ocurren a la resolución de nucleosomas individuales, ChromHMM parte el genoma
en ventanas de 200 nucleótidos por defecto, lo cual corresponde aproximadamente 
con la resolución de un nucleosoma y una región espaciadora. Para cada intervalo
genómico, el software determina la presencia o ausencia de cada marca basándose
en la significancia del recuento observado de lecturas de secuenciación en 
relación con una distribución _background_ de Poisson o, alternativamente, 
mediante una binarización especificada por el usuario como las de los 
_peak callers_ (esto es lo que hicimos supongo, aunque no sé que _peak caller_
utilizamos). ChromHMM usa las resultantes llamadas de presencia y ausencia para
aprender el modelo de estados de cromatina. 


# Paper Enrique 

Genomic annotation was carried out with HOMER software v4.7.2 (25). The tool 
annotatePeaks.pl was used with default parameters to annotate CDRs to genes 
with the following priority assigned: TSS (from −1kb to +100bp), 
transcription termination site (from −100bp to +1kb), protein coding exon, 
5′-UTR exon, 3′-UTR exon, intron and intergenic. More detailed information is 
available in http://homer.salk.edu/homer/ngs/annotation.html. Gene ontology
(GO) (Biological Process; 26) and Reactome (27) enrichment analysis were done 
adding the -go flag to the annotatePeaks.pl tool. Then, we calculated a P-value
adjusted for multiple testing based on Benjamini–Hochberg correction using the 
p.adjust function in R (v3.2.2). All terms with an adjusted P-value < 0.05 were 
considered significant. We summarized the GO (Biological Process) significant
terms with REVIGO.

The transcription factor motif (TFM) enrichments were performed with the 
findMotifsGenome.pl tool included in HOMER software (v4.7.2; 25). To determine
the relative enrichment of known TFMs we excluded the CDRs referred to 
transcription, as they are related to polymerase elongation and not to 
transcription factors binding. The searches were done against a selected random
background of windows adjusted to have equal GC content distribution in each of
the input sequences. The region size was set up to ‘given’, other parameters
were used by default. More detailed information is available in <http://homer.salk.edu/homer/ngs/peakMotifs.html>. The TFMs with a 
q-value < 0.01 at least in one cell type were considered significant and 
selected to generate Figure 3C. We did not find enriched TFMs for T cells
and neutrophils. The expression analyses for 28 of the transcription factor 
binding proteins of Figure 3C were performed with the same approach described 
above, the transcription factors in HSCs were not included in the expression
analysis since BDAP does not provide data for HSCs.

Chromatin state transitions among cell types were represented with a Sankey 
diagram in Figure 3A using the ‘makeRiver’ and ‘riverplot’ functions included
in the ‘riverplot’ R package.


# annotatr

**Links:**
* <https://bioconductor.org/packages/release/bioc/vignettes/annotatr/inst/doc/annotatr-vignette.html>

* Con ``annotatr`` podemos utilizar las anotaciones que tiene el paquete precargadas
y construir el objeto de anotaciones con la función ``build_annotations()``. 
* Con la función ``annotate_regions()`` construimos la referencia, devolviendo 
un obejto ``GRanges``. Dicho objeto poddrá se convertido en un dataframe y hacer
búsquedas de interés en él. 
* Permite además randomizar regiones con el objetivo de tener una comparación. 

```{r}
regionsE1 <- read_regions(file.path(projectPath, "bed_E1_filtrado_0.7", "intersect_E1_f0.7.bed"),
                          genome = "hg19", format = "bed", rename_name = "state")

annots = c('hg19_cpgs', 'hg19_basicgenes', 'hg19_genes_intergenic')

annotations = build_annotations(genome = 'hg19', annotations = annots)

# Intersect the regions we read in with the annotations
dm_annotated = annotate_regions(
    regions = regionsE1,
    annotations = annotations,
    ignore.strand = TRUE,
    quiet = FALSE)
# A GRanges object is returned
dfAnnotated <- data.frame(dm_annotated)

dfAnnotatedNOTCH1 <- subset(dfAnnotated, annot.symbol == "NOTCH1")

dfAnnotatedNOTCH1
```

Como curiosidad, NOCHT1 tiene el estado que estudiamos en los intrones en lugar
de en los promotores. 

```{r}
dm_annsum_rnd = summarize_annotations(
    annotated_regions = dm_annotated,
    quiet = TRUE)

dm_annsum_rnd

```
```{r}
plot_annotation(annotated_regions = dm_annotated,
                plot_title = '# of Sites Tested for DM annotated',
                x_label = 'knownGene Annotations',
                y_label = 'Count')
```


# ChIPpeakAnno

**Links:**
* <https://www.bioconductor.org/packages/devel/bioc/vignettes/ChIPpeakAnno/inst/doc/ChIPpeakAnno.html>
* <https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-11-237>

* Está pensado para ChipSeq, mejor ``annotatr``.
* Permite hacer enriquecimiento funcional.

```{r}
bed1 <- toGRanges(file.path(projectPath, "bed_E1_filtrado_0.7", "intersect_E1_f0.7.bed"),
                  format = "BED", header = FALSE) 
  
annoData <- toGRanges(EnsDb.Hsapiens.v75, feature="gene")

overlaps.anno <- annotatePeakInBatch(bed1, AnnotationData=annoData, 
                                    output="overlapping", maxgap=5000L)
overlaps.anno$gene_name <- annoData$gene_name[match(overlaps.anno$feature,
                             names(annoData))]
dfOverlaps <- data.frame(overlaps.anno)
```


# ChIPseeker

**Links:**
* <http://bioconductor.org/packages/devel/bioc/vignettes/ChIPseeker/inst/doc/ChIPseeker.html>
* <https://bioconductor.org/packages/release/bioc/vignettes/GenomicFeatures/inst/doc/GenomicFeatures.pdf>

Una cosa interesante es que permite la creación de objetos ``TxDb`` mediante 
búsquedas den Biomart y UCSC con las funciones ``makeTxDbFromBiomart`` y 
``makeTxDbFromUCSC``. De esta forma, mediante búsquedas en las bases de datos,
se pueden hacer anotaciones más específicas. Es el tipo de objeto que utilizan 
otros paquetes como ``annotatr``.


```{r}
peakTest <- readPeakFile(file.path(projectPath, "bed_E1_filtrado_0.7", "intersect_E1_f0.7.bed"))
```

Esta figura solo te enseña la presencia/ausencia del estado. Podríamos, con el
objetivo de ponderarlo de alguna manera, dalre la probabilidad de que este 
estado esté ahí. 

```{r, fig.asp=2}
covplot(peakTest)
```

```{r}
peakAnno <- annotatePeak(peakTest, tssRegion=c(-3000, 3000),
                         TxDb=TxDb.Hsapiens.UCSC.hg19.knownGene::TxDb.Hsapiens.UCSC.hg19.knownGene, 
                         annoDb="org.Hs.eg.db")
plotAnnoPie(peakAnno)
plotAnnoBar(peakAnno)
upsetplot(peakAnno)

plotDistToTSS(peakAnno,
              title="Distribution of transcription factor-binding loci\nrelative to TSS")
```

```{r}
pathway1 <- enrichPathway(as.data.frame(peakAnno)$geneId)
head(data.frame(pathway1))
```

Tarda muchísimo.

```{r}
genes = data.frame(peakAnno)$geneId
genes = sub("_", "\n", genes)
compKEGG <- compareCluster(geneCluster   = genes[1:2000],
                         fun           = "enrichKEGG",
                         pvalueCutoff  = 0.05,
                         pAdjustMethod = "BH")
dotplot(compKEGG, showCategory = 15, title = "KEGG Pathway Enrichment Analysis")
```


# Resumen

* Entre ``annotatr`` y ``ChIPpeakAnno``, parece que el primero es capaz de 
encontrar más anotaciones por segmento. ``ChIPseeker`` saca también bastantes,
aunque también está pensado para picos. 
* ``annotatr`` parece que da anotaciones repetidas. Igual tiene que ver con 
las referencias que uso, que alguna de ellas es redundante, pero habría que 
tener cuidado con ello. 
* ``ChIPpeakAnno`` está pensado para picos, mientras que ``annotatr`` parece
que tiene un propósito más general. El primero devuelve distancias al gen más
cercano, etc. lo cual no sé si tiene sentido con lo que estamos trabajando, 
que son estados de cromatina. En realidad podría ser, pero no lo sé. 
* Respecto al análisis de enriquecimiento, lo he hecho por probar, nada más. 
Hay mejores opciones para hacerlo, aunque solo con KEGG es una posibilidad. 












