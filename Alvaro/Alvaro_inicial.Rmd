---
title: "Alvaro_inicial"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Opcional

```{r}
rm(list=ls())
load("Resultados_Alvaro.RData")
```

# Paquetes que hay que instalar

```{r}
# From Bioconductor
if (!requireNamespace("BiocManager", quietly = TRUE))
        install.packages("BiocManager")

BiocManager::install("affy")
BiocManager::install("limma")
BiocManager::install("genefilter")
```

# Cargamos las librerías

```{r}
# Load required libraries
library("affy")
library("limma")
library("genefilter")
```

# Eliminamos elementos del espacio
Eliminamos todas los elementos del espacio por si queremos guardar el resultado de este script en una sesión

```{r}
# Remove previous loaded objects to avoid errors
rm(list=ls())
```

# Cargamos los ficheros .CEL y extraemos el raw data

```{r}
# Target file 
targets <- readTargets("target.txt", row.names="FileName")

# Check that the .CEL files available in the directory are the one expected
CELfiles <- list.celfiles()
CELfiles
length(CELfiles) == 12

# Read .CEL files 
# data <- ReadAffy(filenames=targets$FileName)
rawdata <- ReadAffy(filenames = CELfiles)
rawdata
```

# Análisis exploratorio de la calidad de los datos iniciales


```{r}
# Exploratory graphs that provide information about the quality of the arrays
library("RColorBrewer")

# Select 4 different color in the palette Set1. Return them in a vector
usr.col <- brewer.pal(4, "Set1")

# Repeat each color three times, such there are three arrays per sample type
mycols <- rep(usr.col, each = 3)
```

## Distribución de las intensidades

```{r}
#########################
# Intensity distributions
#########################

# Show intensity distributrions with hist function 
hist(rawdata, lty = rep(1, length(CELfiles)), col = mycols,
     main = "Intensity distributions Before Normalization")

# Add legend in the top right corner 
legend("topright", rownames(pData(rawdata)),
       lty = rep(1, length(CELfiles)), 
       col = mycols,
       cex = 0.6)

# Tema 19 página 637. Vemos que no hay problemas y que no tenemos que descartar
# ningún array, aunque sí es importante normalizar. No hay ninguno con un valor
# muy alto en log intensity. También vemos que todos tienen una distribución 
# más o menos igual. 
```

## Boxplot

```{r}
#############################
# boxplot antes de normalizar
#############################

boxplot(rawdata,
        main="Boxplot Before Normalization",
        col = mycols,
        names = sampleNames(rawdata),
        las = 2,  # vertical labels
        cex.axis = 0.6, # size labels
        yaxt = "n") # do not show y labels
axis(2, cex.axis = 1) # plot y labels with higher size
```

# Normalización

## Normalización con RMA

```{r}
#4. Normalize with RMA 
#generates object eset (class ExprSet), 
#expresso function provides intensities in log scale
eset <- expresso(rawdata,
                 bg.correct = TRUE, 
                 bgcorrect.method="rma", # corregir fondo
                 normalize = TRUE, 
                 normalize.method="quantiles", 
                 pmcorrect.method="pmonly", # los que machean perfectamente
                 summary.method="medianpolish", # resumeme por la mediana par aun mismo gen
                 verbose = TRUE,
) 
```

### Distribución de la intensidad tras la normalización 
```{r}
#########################
# Intensity distributions
#########################

# Show intensity distributrions
exprseset <- as.data.frame(exprs(eset))
dens <- apply(data.frame(exprseset), 2, density)

plot(NA, xlim=range(sapply(dens, "[", "x")), ylim=range(sapply(dens, "[", "y")))
mapply(lines, dens, col=mycols)

# Add legend in the top right corner
legend("topright", legend=names(dens), lty = rep(1, length(CELfiles)), col = mycols, cex = 0.6)
```

### Boxplots tras la normalización

```{r}
# boxplot de todos los genes después de normalizar
exprseset <- as.data.frame(exprs(eset))	# cojo las intensidades normalizadas	
boxplot(data.frame(exprseset),
        main="Boxplot After Normalization (log scale)",
        col = mycols,
        names = sampleNames(rawdata),
        las = 2,  # vertical labels
        cex.axis = 0.6, # size labels
        yaxt = "n") # do not show y labels
axis(2, cex.axis = 1) # plot y labels with higher size
```

### Filtro del rango intercuartílico

```{r}
# boxplot de solo los genes normalizados con un ranog intercuartílico superior a 0.5 para que tengan variabilidad
esetIQR <- varFilter(eset, var.func=IQR, var.cutoff=0.5, filterByQuantile=TRUE)

## Comprobamos el filtro del rango intercuartílico
dim(exprs(eset))
dim(exprs(esetIQR))



# boxplot de solo los genes normalizados con un ranog intercuartílico superior a 0.5 para que tengan variabilidad
esetIQR <- varFilter(eset, var.func=IQR, var.cutoff=0.5, filterByQuantile=TRUE)

exprseset <- as.data.frame(exprs(esetIQR))	# cojo las intensidades normalizadas	

boxplot(data.frame(exprseset),
        main="Boxplot After Normalization (log scale)",
        col = mycols,
        names = sampleNames(rawdata),
        las = 2,  # vertical labels
        cex.axis = 0.6, # size labels
        yaxt = "n") # do not show y labels
axis(2, cex.axis = 1) # plot y labels with higher size
```

# Expresión diferencial

Generamos la matriz donde guardaremos el diseño experimental que empleará makeContrast para realizar la comparación de niveles de transcripción. 

```{r}
# design<-cbind(C1=c(rep(1, 3), rep(0, 9)), C2=c(rep(0,3), rep(1, 3), rep(0, 6)), S1=c(rep(0, 6), rep(1, 3), rep(0, 3)), S2 = c(rep(0, 9), rep(1, 3)) )
design <- model.matrix(~ 0+factor(c(1,1,1,2,2,2,3,3,3,4,4,4)))
rownames(design)<-targets$FileName
colnames(design) <- c("C1", "C2", "S1", "S2")
```

Realizamos el ajuste de cada grupo a una recta y realizamos el estudio de expresión diferencial

```{r}
## ajustamos cada nube de puntos correspondiente a cada grupo a una recta
fit<-lmFit(esetIQR,design)

## establecemos las comparaciones que queremos realizar
## Tenemos que dividir entre 2 para que tengan todos el mismo peso. Las dos últimas no tienen ningún sentido
contrast.matrix <- makeContrasts(C1-C2, S1-C1, S2-C2, ((S1+S2)/2)-((C1+C2)/2), ((S1+S2)/2)-C1, ((S1+S2)/2)-C2, levels=design)

## comparamos las regresiones lineales según el patrón de contraste pedido
fit2 <- contrasts.fit(fit, contrast.matrix)

fit2<-eBayes(fit2)
```

Mostramos los resultados del estudio diferencial

```{r}
#Table with DEGs results number te cogerá todos los genes (filas) que tenia esetIQR

toptableIQR<-topTable(fit2, number=dim(exprs(esetIQR))[1], adjust.method="BH", coef = 3,  sort.by="p") # para poder ordenar por "p" necesito poner el coeficiente, es decir, que sepa que comparación debe coger
# toptableIQR<-toptable(fit2, number=dim(exprs(esetIQR))[1], adjust.method="BH", sort.by="p", coef = 1) DESAPARECERÁ

head(toptableIQR)

```

Ahora quiero quedarme solo con los genes que cumplan un FDR<0.05 (adjusted P-value)
```{r}
Results.fdr.005.table<-subset(toptableIQR, toptableIQR$adj.P.Val<=0.05)
```


Opcional

```{r}
# save.image(file = "Resultados_Alvaro.RData")
```

# Incorporación de los nombres de los genes

```{r, results=FALSE, message=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
        install.packages("BiocManager")

BiocManager::install("hgu133plus2.db")
```

```{r, message=FALSE}
library("hgu133plus2.db")
```

```{r}
Results.fdr.005.table<-subset(toptableIQR, toptableIQR$adj.P.Val<=0.05)

# Recuperamos los nombres de las sondas de los diferentes spots del microarray
probenames.fdr.005<-as.character(rownames(Results.fdr.005.table))
# probenames.fdr.005

# Recuperamos la lista de genes asociados a las diferentes sondas del microarray
list.GeneSymbol.fdr.005<-mget(probenames.fdr.005, hgu133plus2SYMBOL)
# list.GeneSymbol.fdr.005

# ahora mostrmos solo los nombres de los genes
char.GeneSymbol.fdr.005<- as.character(list.GeneSymbol.fdr.005)
# char.GeneSymbol.fdr.005

# Añadimos al data frame la columna con los nombres de los genes
toptable.annotated<-cbind(Results.fdr.005.table,char.GeneSymbol.fdr.005)
# toptable.annotated

# Change name column added
colnames(toptable.annotated)[length(colnames(toptable.annotated))] <- "Gene_Name"

# Get column names
colnames(toptable.annotated)

# Reordering colnumns by positions. We want "Gene_names" as the second column

toptable.annotated<- toptable.annotated[, c("Gene_Name", "logFC", "AveExpr", "t", "P.Value", "adj.P.Val", "B")]
# toptable.annotated
  

```


