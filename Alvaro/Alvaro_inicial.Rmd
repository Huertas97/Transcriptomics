---
title: "Alvaro_Inicial"
author:
- name: Álvaro Huertas García 
  affiliation: Universidad Autonoma de Madrid (UAM)
output:
  BiocStyle::html_document:
    css: "./css/style.css"
    toc: true
    toc_float: true
    
classoption: a4paper
geometry: margin=3cm
fontsize: 12pt
abstract: |
   Transcriptomics 
   (Master's Degree in Bioinformatics and Computational Biology, Universidad 
   Autónoma de Madrid).
vignette: |
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

header-includes:
  - \usepackage{amsmath}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Opcional

```{r}
rm(list=ls())
load("Resultados_Alvaro.RData")
```

# Requisitos

## Paquetes que hay que instalar

```{r results = "hide", warning = FALSE, message = FALSE}
# From Bioconductor
if (!requireNamespace("BiocManager", quietly = TRUE))
        install.packages("BiocManager")

BiocManager::install("affy")
BiocManager::install("limma")
BiocManager::install("genefilter")
BiocManager::install("hgu133plus2.db")
```


## Cargamos las librerías

```{r message = FALSE, results='hide', warning=FALSE}
# Load required libraries

suppressPackageStartupMessages({
library("BiocStyle")
library("affy")
library("limma")
library("genefilter")
library("hgu133plus2.db")})
```

## Eliminamos elementos del espacio
Eliminamos todas los elementos del espacio por si queremos guardar el resultado de este script en una sesión

```{r}
# Remove previous loaded objects to avoid errors
rm(list=ls())
```

# Temporal

##  Cargamos los ficheros .CEL y extraemos el raw data

```{r cargamos-ficheros-CEL, warning=FALSE}
# Target file 
targets <- readTargets("target.txt", row.names="FileName")

# Check that the .CEL files available in the directory are the one expected
CELfiles <- list.celfiles()
CELfiles
length(CELfiles) == 12

# Read .CEL files 
# data <- ReadAffy(filenames=targets$FileName)
rawdata <- ReadAffy(filenames = CELfiles)
rawdata
```

##  Análisis exploratorio de la calidad de los datos iniciales


```{r}
# Exploratory graphs that provide information about the quality of the arrays
library("RColorBrewer")

# Select 4 different color in the palette Set1. Return them in a vector
usr.col <- brewer.pal(4, "Set1")

# Repeat each color three times, such there are three arrays per sample type
mycols <- rep(usr.col, each = 3)
```

### Distribución de las intensidades

```{r Distribucion-intensidades, message = FALSE, warning=FALSE}
#########################
# Intensity distributions
#########################

# Show intensity distributrions with hist function 
hist(rawdata, lty = rep(1, length(CELfiles)), col = mycols,
   main = "Intensity distributions Before Normalization")

# Add legend in the top right corner 
legend("topright", rownames(pData(rawdata)),
       lty = rep(1, length(CELfiles)), 
       col = mycols,
       cex = 0.6)

# Tema 19 página 637. Vemos que no hay problemas y que no tenemos que descartar
# ningún array, aunque sí es importante normalizar. No hay ninguno con un valor
# muy alto en log intensity. También vemos que todos tienen una distribución 
# más o menos igual. 
```

### Boxplot

```{r}
#############################
# boxplot antes de normalizar
#############################

boxplot(rawdata,
        main="Boxplot Before Normalization",
        col = mycols,
        names = sampleNames(rawdata),
        las = 2,  # vertical labels
        cex.axis = 0.6, # size labels
        yaxt = "n") # do not show y labels
axis(2, cex.axis = 1) # plot y labels with higher size
```


## Normalización con RMA

```{r}
#4. Normalize with RMA 
#generates object eset (class ExprSet), 
#expresso function provides intensities in log scale
eset <- expresso(rawdata,
                 bg.correct = TRUE, 
                 bgcorrect.method="rma", # corregir fondo
                 normalize = TRUE, 
                 normalize.method="quantiles", 
                 pmcorrect.method="pmonly", # los que machean perfectamente
                 summary.method="medianpolish", # resumeme por la mediana par aun mismo gen
                 verbose = TRUE,
) 
```

### Distribución de la intensidad tras la normalización 

```{r message = FALSE}
#########################
# Intensity distributions
#########################

# Show intensity distributrions
exprseset <- as.data.frame(exprs(eset))
dens <- apply(data.frame(exprseset), 2, density)

plot(NA, xlim=range(sapply(dens, "[", "x")), ylim=range(sapply(dens, "[", "y")))
distribution <- mapply(lines, dens, col=mycols)

# Add legend in the top right corner
legend("topright", legend=names(dens), lty = rep(1, length(CELfiles)), col = mycols, cex = 0.6)
```

### Boxplots tras la normalización

```{r}
# boxplot de todos los genes después de normalizar
exprseset <- as.data.frame(exprs(eset))	# cojo las intensidades normalizadas	
boxplot(data.frame(exprseset),
        main="Boxplot After Normalization (log scale)",
        col = mycols,
        names = sampleNames(rawdata),
        las = 2,  # vertical labels
        cex.axis = 0.6, # size labels
        yaxt = "n") # do not show y labels
axis(2, cex.axis = 1) # plot y labels with higher size
```

### Filtro del rango intercuartílico

```{r}
# boxplot de solo los genes normalizados con un ranog intercuartílico superior a 0.5 para que tengan variabilidad
esetIQR <- varFilter(eset, var.func=IQR, var.cutoff=0.5, filterByQuantile=TRUE)

## Comprobamos el filtro del rango intercuartílico
dim(exprs(eset))
dim(exprs(esetIQR))



# boxplot de solo los genes normalizados con un ranog intercuartílico superior a 0.5 para que tengan variabilidad
esetIQR <- varFilter(eset, var.func=IQR, var.cutoff=0.5, filterByQuantile=TRUE)

exprseset <- as.data.frame(exprs(esetIQR))	# cojo las intensidades normalizadas	

boxplot(data.frame(exprseset),
        main="Boxplot After Normalization (log scale)",
        col = mycols,
        names = sampleNames(rawdata),
        las = 2,  # vertical labels
        cex.axis = 0.6, # size labels
        yaxt = "n") # do not show y labels
axis(2, cex.axis = 1) # plot y labels with higher size
```





## Expresión diferencial

Generamos la matriz donde guardaremos el diseño experimental que empleará makeContrast para realizar la comparación de niveles de transcripción. A cada archivo .CEL le asigno un número en función del tratamiento y línea celular.

* KOPT-K1_DMSO $\rightarrow$ 1

* HPB-ALL_DMSO $\rightarrow$ 2

* KOPT-K1_SAHM1 $\rightarrow$ 3

* HPB-ALL_SAHM1 $\rightarrow$ 4

```{r}
# design<-cbind(C1=c(rep(1, 3), rep(0, 9)), C2=c(rep(0,3), rep(1, 3), rep(0, 6)), S1=c(rep(0, 6), rep(1, 3), rep(0, 3)), S2 = c(rep(0, 9), rep(1, 3)) )
design <- model.matrix(~ 0+factor(c(1,1,1,2,2,2,3,3,3,4,4,4)))
rownames(design)<-targets$FileName
colnames(design) <- c("KOPT_DMSO", "HPB_DMSO", "KOPT_SAHM1", "HPB_SAHM1")
```

Realizamos el ajuste de cada grupo a una recta y realizamos el estudio de expresión diferencial empleando 
la función * makeContrast *

```{r}
## ajustamos cada nube de puntos correspondiente a cada grupo a una recta
fit<-lmFit(esetIQR,design)

## establecemos las comparaciones que queremos realizar
## Tenemos que dividir entre 2 para que tengan todos el mismo peso. Las dos últimas no tienen ningún sentido
contrast.matrix <- makeContrasts(KOPT_DMSO - HPB_DMSO, # C1 - C2 # Ver si hay diferencia entre los controles
                                 KOPT_SAHM1 - HPB_SAHM1, # S1 - S2 # Ver si hay diferencia entre los tratamientos
                                 KOPT_SAHM1 - KOPT_DMSO, # S1 - C1 # Interesante
                                 HPB_SAHM1 - HPB_DMSO,    # S2 - C2 # Interesante
                                 ((KOPT_SAHM1 + HPB_SAHM1)/2) - ((KOPT_DMSO + HPB_DMSO)/2), # (S1 + S2) - (C1 + C2)
                                 ((KOPT_SAHM1 + HPB_SAHM1)/2) - KOPT_DMSO,  # (S1 + S2) - C1 No tiene sentido
                                 ((KOPT_SAHM1 + HPB_SAHM1)/2) - HPB_DMSO, # (S1 + S2) - C2 No tiene sentido
                                 levels=design)

## comparamos las regresiones lineales según el patrón de contraste pedido
fit2 <- contrasts.fit(fit, contrast.matrix)

fit2<-eBayes(fit2)
```




```{r}
#Table with DEGs results number te cogerá todos los genes (filas) que tenia esetIQR

toptableIQR<-topTable(fit2, number=dim(exprs(esetIQR))[1], adjust.method="BH", coef = 3,  sort.by="p") # para poder ordenar por "p" necesito poner el coeficiente, es decir, que sepa que comparación debe coger
# toptableIQR<-toptable(fit2, number=dim(exprs(esetIQR))[1], adjust.method="BH", sort.by="p", coef = 1) DESAPARECERÁ

head(toptableIQR)

```

Ahora quiero quedarme solo con los genes que cumplan un FDR<0.05 (adjusted P-value)
```{r}
Results.fdr.005.table<-subset(toptableIQR, toptableIQR$adj.P.Val<=0.05)
dim(Results.fdr.005.table)
```


Opcional

```{r}
# save.image(file = "Resultados_Alvaro.RData")
```

## Incorporación de los nombres de los genes

```{r, results=FALSE, message=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
        install.packages("BiocManager")

BiocManager::install("hgu133plus2.db")
```

```{r, message=FALSE, results=FALSE, warning=FALSE}
library("hgu133plus2.db")
```

```{r}
Results.fdr.005.table<-subset(toptableIQR, toptableIQR$adj.P.Val<=0.05)

# Recuperamos los nombres de las sondas de los diferentes spots del microarray
probenames.fdr.005<-as.character(rownames(Results.fdr.005.table))
head(probenames.fdr.005)

# Recuperamos la lista de genes asociados a las diferentes sondas del microarray
list.GeneSymbol.fdr.005<-mget(probenames.fdr.005, hgu133plus2SYMBOL)
head(list.GeneSymbol.fdr.005)

# ahora mostrmos solo los nombres de los genes
char.GeneSymbol.fdr.005<- as.character(list.GeneSymbol.fdr.005)
head(char.GeneSymbol.fdr.005)

# Añadimos al data frame la columna con los nombres de los genes
toptable.annotated<-cbind(Results.fdr.005.table,char.GeneSymbol.fdr.005)
head(toptable.annotated)
```

Reordenamos las columnas colocando la nueva columna con los nombres de los genes en primer lugar

```{r}
# Change name column added
colnames(toptable.annotated)[length(colnames(toptable.annotated))] <- "Gene_Name"

# Get column names
colnames(toptable.annotated)

# Reordering colnumns by positions. We want "Gene_names" as the second column

toptable.annotated<- toptable.annotated[, c("Gene_Name", "logFC", "AveExpr", "t", "P.Value", "adj.P.Val", "B")]
head(toptable.annotated)
  

```



# Diseño del trabajo de análisis

## Diseño del análisis

Para el trabajo será interesante realizar dos tipos de estudios:

**1. Podemos analizar las dos líneas por separado y ver si sacamos los mismos
resultados, lo que indicaría que las dos líneas celulares son equivalentes, pero
si salen resultados diferentes podemos concluir que son líneas independientes**

**2. Podemos juntar las dos líneas celulares y comparar simplemente el efecto de 
los tratamientos DMSO y SAMH1.** Aquí estaríamos comprobando si hay un efecto o 
patrón común en ambas líneas celulares.



También vemos que los arrays de las dos líneas muestran diferencias tras la normalización, 
independientemente del tratamiento. Es decir, vemos que los boxplots las muestras de la línea
KOPT-K1 

## Lineas celulares estudiadas por separado: KOPT-K1_SAHM1 vs KOPT-K1_DMSO y HPB-ALL_SAHM1 vs HPB-ALL_DMSO

Aquí la hipótesis es que las líneas celulares afectan a la expresión de genes y,
por tanto, es necesario estudiar de forma independiente (separada) las líneas
celulares. Para ello debo normalizar y comparar por separado cada línea celular. 

Si el resultado de la lista de genes diferencialmente expresados es similar entre
ambas líneas celulares es que ambas líneas celulares se comportan igual. Si no, 
indica que se comportan de forma diferente y no se pueden agrupar. 

**¿En qué caso puedo comparar los controles entre tipos celulares y los tratamientos
de SAHM1 entre tipos celulares?**
Es decir, lo que quiero es ver si hay diferencia entre los controles y ver si
hay diferencias entre los tratamientos. 

**Lo más interesante creo que sería comparar los controles, porque ya te
dice si en condiciones normales los genes que se expresan son diferentes o no **

Estudiar la diferencia entre los tratamientos entre distintos tipos celulares 
directamente sería incorrecto, porque precisamente necesitas un control, que es 
lo que precisamente hacemos antes. 


**Conclusión**:

1. Primero veremos si hay grandes diferencias entre los controles KOPT-K1_DMSO y
HPB-ALL_DMSO. Esto es un estudio inicial para ver si ya se observan diferencias 
entre ambas líneas celulares. $\rightarrow$ $H_{0}:$ las dos líneas celulares
son iguales. Vemos boxplot y distribución de intensidades. Normalizamos. Análisis
de expresión diferencial. Ver si hay diferencias. 

2. Tras la aproximación inicial en la que vemos si las líneas celulares son iguales
o no hacemos el estudio independiente. 

3. 


## Líneas celulares estudiadas conjuntamente: DMSO vs SAHM1

Aquí la hipótesis es que las líneas celulares se comportan igual en ambos escenarios
(tratamiento con DMSO y tratamiento con SAHM1). Comprobaremos que patrón común 
presentan ambas líneas celulares, es decir, que genes se encuentran diferencialmente
expresados en DMSO con respecto a SAHM1 independientemente del tipo celular utilizado. 

**¿Es correcto este estudio?**
Considero que primero hay que estudiar por separado las dos líneas celulares y, 
si vemos que los genes que se encuentran diferencialmente expresados en las dos
líneas celulares son prácticamente los mismos, podemos proponer que la línea celular
no afecta. Por tanto, diríamos que hacer el estudio agrupando las líneas celulares
sería correcto. En caso de que por separado encontramos diferencias, sería
incorrecto agrupar las dos líneas celulares. 


En este caso la normalización debería hacerse con las 12 muestras a la vez, porque
para obtener la lista de genes diferencialmente expresados voy a comparar los 6
microarrays de SAHM1 vs los 6 microarrays de DMSO y aquí (como no me importa de
qué tipo celular provenga la muestra) sí que necesito que la normalización se
realice conjuntamente.

**Conclusión**
* Los arrays que vayas a usar para comparar y obtener la lista de genes diferencialmente
expresados tienes que normalizarlos conjuntamente. 

* Puedes comparar los resultados de las listas de genes diferencialmente expresados
entre los dos tipos celulares habiendo normalizado los arrays por separado.
Porque la lista de genes diferencialmente expresados ya es el resultado final, que 
has sacado normalizando entre los arrays correspondientes. Cuando comparas las
listas de genes diferencialmente expresados, lo que estás haciendo es comparar las 
dos líneas celulares, y **sería incorrecto normalizar conjuntamente ambos tipos 
celulares y luego comparar los genes diferencialmente expresados por separado.**

* Normaliza conjuntamente aquello que vayas a comparar para encontrar genes
diferencialmente expresados

# Comparación controles

##  Cargamos los ficheros .CEL y extraemos el raw data

Los ficheros control son:

* KOPT-K1_DMSO $\rightarrow$ "GSM455115.CEL", "GSM455116.CEL", "GSM455117.CEL"

* HPB-ALL_DMSO $\rightarrow$ "GSM455118.CEL", "GSM455119.CEL", "GSM455120.CEL"

```{r cargamos-ficheros-CEL-control, warning=FALSE}

# Read .CEL files 
# data <- ReadAffy(filenames=targets$FileName)
CELfiles_control <- c("GSM455115.CEL", "GSM455116.CEL", "GSM455117.CEL", "GSM455118.CEL", "GSM455119.CEL", "GSM455120.CEL")

rawdata_control <- ReadAffy(filenames = CELfiles_control)
rawdata_control
```

##  Análisis exploratorio de la calidad de los datos iniciales


```{r}
# Exploratory graphs that provide information about the quality of the arrays
library("RColorBrewer")

# Select 9 (maximum) different color in the palette Set1. Return them in a vector
usr.col <- brewer.pal(9, "Set1")

# Repeat each color three times, such there are three arrays per sample type
mycols <- rep(usr.col, each = 3)
```

### Distribución de las intensidades

```{r Distribucion-intensidades-control, message = FALSE, warning=FALSE}
#########################
# Intensity distributions
#########################

# Show intensity distributrions with hist function 
hist(rawdata_control, lty = rep(1, length(CELfiles_control )), col = mycols,
   main = "Intensity distributions Before Normalization")

# Add legend in the top right corner 
legend("topright", rownames(pData(rawdata_control)),
       lty = rep(1, length(CELfiles_control )), 
       col = mycols,
       cex = 1)

# Tema 19 página 637. Vemos que no hay problemas y que no tenemos que descartar
# ningún array, aunque sí es importante normalizar. No hay ninguno con un valor
# muy alto en log intensity. También vemos que todos tienen una distribución 
# más o menos igual. 
```

Observamos que entre microarrays del tipo celular KOPT-T1 la distribución es muy parecida, pero en el caso del tipo celular HPB-ALL existen diferencias en la distribución entre microarrays, aunque nada preocupante. También se observa que la distribución entre tipos celulares es diferente. 

### Boxplot

```{r}
#############################
# boxplot antes de normalizar
#############################

boxplot(rawdata_control,
        main="Boxplot Before Normalization",
        col = mycols,
        names = sampleNames(rawdata_control),
        las = 2,  # vertical labels
        cex.axis = 0.6, # size labels
        yaxt = "n") # do not show y labels
axis(2, cex.axis = 1) # plot y labels with higher size
```

Volvemos a observar los mismo que en el gráfico de las distribuciones de intensidades: existe mayor variación entre los microarrays pertenecientes al tipo celular HPB-ALL, que en el caso del tipo celular KOPT-K1. No obstante, no hay nada preocupante. 


```{r control-scatter-plot1}

# Note that the original eset object contains the log2-transformed gene intensities

intens_rawdata_control <-  as.data.frame(exprs(rawdata_control)) 
intens_rawdata_control_KOPT <- apply(intens_rawdata_control[, c(1, 2, 3)], 1, mean)
intens_rawdata_control_HPB <-  apply(intens_rawdata_control[, c(4, 5, 6)], 1, mean)

plot(intens_rawdata_control_KOPT, intens_rawdata_control_HPB, cex = 1, 
     pch = 19, col = "mediumaquamarine",
     xlab = "KOPT-K1",
     ylab = "HPB-ALL",
     main = "Cell lines control expression level before normalization")

abline(a = 0,
       b = (max(intens_rawdata_control_HPB) / max(intens_rawdata_control_KOPT)), col = "red",
       lwd = 2)
```

```{r MA-plot-control}
A <- 1/2*log2(intens_rawdata_control_KOPT*intens_rawdata_control_HPB)
M <- log2(intens_rawdata_control_KOPT/intens_rawdata_control_HPB)
plot(A, M, cex = 0.75, pch = 19, col = "steelblue", 
     main = "Cell lines control expression level before normalization" )
```


## Normalización con RMA

```{r Normalizacion-RMA-control}
#4. Normalize with RMA 
#generates object eset (class ExprSet), 
#expresso function provides intensities in log scale
eset_control <- expresso(rawdata_control,
                 bg.correct = TRUE, 
                 bgcorrect.method="rma", # corregir fondo
                 normalize = TRUE, 
                 normalize.method="quantiles", 
                 pmcorrect.method="pmonly", # los que machean perfectamente
                 summary.method="medianpolish", # resumeme por la mediana par aun mismo gen
                 verbose = TRUE,
) 
```

### Distribución de la intensidad tras la normalización 

```{r control-intensity-normalizado, message = FALSE}
#########################
# Intensity distributions
#########################

# Show intensity distributrions
exprseset_control <- as.data.frame(exprs(eset_control)) # cojo las intensidades normalizadas
dens_control <- apply(data.frame(exprseset_control), 2, density)

plot(NA, xlim=range(sapply(dens_control, "[", "x")), 
     ylim=range(sapply(dens_control, "[", "y")),
     main = "Intensity distributions controls After Normalization",
     xlab = "log intensity", ylab = "density")
distribution_control <- mapply(lines, dens_control, col=c(rep(mycols[1], 3), rep(mycols[4], 3)), lwd = 1)

# Add legend in the top right corner
legend("topright", legend=names(dens_control), lty = rep(1, length(CELfiles_control)), col = mycols, cex = 1)
```

### Boxplots tras la normalización

```{r control-boxplot-normalizado}
# boxplot de todos los genes después de normalizar
boxplot(data.frame(exprseset_control),
        main="Boxplot Controls After Normalization (log scale)",
        col = mycols,
        names = sampleNames(rawdata_control),
        las = 2,  # vertical labels
        cex.axis = 0.6, # size labels
        yaxt = "n") # do not show y labels
axis(2, cex.axis = 1) # plot y labels with higher size
```


### Scatter plot and MA-plot

(Tema 17 Pág 521 )
The scatter plot is probably the simples tool that can be used for a comparative
analysis of DNA expression levels. 
In the scatter plot, each axis corresponds to an experiment (in our case, a microarray)
and each expression level corresponding to an individual gene is represented as 
a point. 

Scatter plots are very useful to convey information about the data. 
If a gene G has an expression level of $e_{1}$ in the first experiment, the point 
representing G will be plotted at coordinates $(e_{1}, e_{2})$ in the scatter 
plot. 
In such a plot, genes with similar expression levels will appear somewhere on
the first diagonal (the line $y = x$) of the coordinate system. A gene that
has an expression level that is very different between the two experiments
will appear far from the diagonal.

If we apply it to our case, the scatter plot allows us to analyze in an 
exploratory way if the levels of expression between the cell line KOPT-K1 and 
BPH-ALL in treatment with DMSO present great differences or not. Remember that
our null hypothesis is that both cell lines have no difference in the expression
levels. Before making this type of plot, to carry out the comparative 
study, it is necessary to eliminate the background and normalize the data 
(as we have done previously). 

```{r control-scatter-plot}

# Note that the original eset object contains the log2-transformed gene intensities

exprseset_control <- as.data.frame(exprs(eset_control)) # retrieve log2 intensities
head(exprseset_control) # show log2 intensities
intens_control = 2^exprseset_control # transform from log2 to normal intensity
head(intens_control)

```

As we can see we have three samples for each cell line. In order to show the
scatter plot it is neccesary to merge these three samples in one value. 
We have previously checked that the distribution of the intensities of the 
different replicates of each cell type ishomogeneous, so we can reduce the 
values of the three samples to a single value corresponding to their mean.  
I consider the mean to be adequate since the study of the distributions and 
boxplots does not show that any of the replicates is an outlier, in which case 
that sample would have been eliminated. 

```{r}
# mean intensity for KOPT-K1 control DMSO
intens_control_KOPT = apply(intens_control[, c(1, 2, 3)], 1, mean)
# mean intensity for HPB-ALL control DMSO
intens_control_HPB = apply(intens_control[, c(4, 5, 6)], 1, mean)

plot(intens_control_KOPT, intens_control_HPB, cex = 1, 
     pch = 19, col = "mediumaquamarine",
     xlab = "KOPT-K1",
     ylab = "HPB-ALL",
     main = "Cell lines control expression level after normalization")

abline(a = 0,
       b = (max(intens_control[, 4]) / max(intens_control[, 1])), col = "red",
       lwd = 2)

```


The scatter plot allows us to observe that most genes are located on the diagonal
and there is no pattern in the point cloud, so most of the genes studied are 
expressed at similar levels in both cell types. However, there are some genes 
that are separated from the diagonal, being more expressed in one of the two 
cell types. It is interesting to continue with the differential expression 
analysis based on statistical methods to check if these differences are 
significant and we must study the cell lines separately.


**Tiene sentido???**
Another type of plot  used for array data is the ratio-versus-intensity plot
(MA-plot). In this plot, in the y axis the intensity rario (M) is plotted against
the average intensity (A). 

We assume that most of the genes would not see any change in ther expression 
between KOPT-K1 and HPB-ALL cell lines, so they will be plot among $y=0$

```{r}
A <- 1/2*log2(intens_control_KOPT*intens_control_HPB)
M <- log2(intens_control_KOPT/intens_control_HPB)
plot(A, M, cex = 0.75, pch = 19, col = "steelblue", 
     main = "Cell lines control expression level after normalization" )
```

Tras normalizar vemos que el MA-plot ahora tiene más genes en el valor $y=0$. 
volvemos a ver que la mayoría de genes se sitúa en torno al valor central $y=0$,
lo que indica que se expresan igual en ambos tipos celulares. No obstante, 
existen genes que se alejan de este valor central que deben ser estudiados. 


### Filtro del rango intercuartílico

```{r control-IQR}
# boxplot de solo los genes normalizados con un ranog intercuartílico superior a 0.5 para que tengan variabilidad
esetIQR_control <- varFilter(eset_control, var.func=IQR, var.cutoff=0.5, filterByQuantile=TRUE)

## Comprobamos el filtro del rango intercuartílico
dim(exprs(eset_control))
dim(exprs(esetIQR_control))



# boxplot de solo los genes normalizados con un ranog intercuartílico superior a 0.5 para que tengan variabilida
exprsesetIQR_control <- as.data.frame(exprs(esetIQR_control))

boxplot(data.frame(exprsesetIQR_control),
        main="Boxplot Controls After Normalization and IQR filter (log scale)",
        col = mycols[1:6],
        names = sampleNames(rawdata_control),
        las = 2,  # vertical labels
        cex.axis = 0.6, # size labels
        yaxt = "n") # do not show y labels
axis(2, cex.axis = 1) # plot y labels with higher size
```




## Expresión diferencial

### Análisis estadístico

Generamos la matriz donde guardaremos el diseño experimental que empleará _makeContrast_ 
para realizar la comparación de niveles de transcripción. A cada archivo .CEL 
le asigno un número en función del tratamiento y línea celular.

* KOPT-K1_DMSO $\rightarrow$ 1

* HPB-ALL_DMSO $\rightarrow$ 2


```{r}

# Generamos la matriz de diseño experimental
design_control <- model.matrix(~ 0+factor(c(1,1,1,2,2,2)))
rownames(design_control)<-sampleNames(rawdata_control)
colnames(design_control) <- c("KOPT_DMSO", "HPB_DMSO")
```

Realizamos el ajuste de cada grupo a una recta y realizamos el estudio de expresión diferencial empleando 
la función *makeContrast*

```{r}
## ajustamos cada nube de puntos correspondiente a cada grupo a una recta
fit_control <- lmFit(esetIQR_control, design_control)

## establecemos las comparaciones que queremos realizar
## Tenemos que dividir entre 2 para que tengan todos el mismo peso. Las dos últimas no tienen ningún sentido
contrast.matrix_control <- makeContrasts(KOPT_DMSO - HPB_DMSO, levels=design_control)

## comparamos las regresiones lineales según el patrón de contraste pedido
fit2_control <- contrasts.fit(fit_control, contrast.matrix_control)

fit2_control<-eBayes(fit2_control)
```




```{r}
#Table with DEGs results number te cogerá todos los genes (filas) que tenia esetIQR

toptableIQR_control<-topTable(fit2_control, number=dim(exprs(esetIQR_control))[1],
                              adjust.method="BH", coef = 1,  sort.by="p") 
# para poder ordenar por "p" necesito poner el coeficiente, es decir, que sepa que comparación debe coger

head(toptableIQR_control)

```

Ahora quiero quedarme solo con los genes que cumplan un FDR<0.05 (adjusted P-value)

```{r}

# Data frame with the values of the spot
Control.fdr.005.table<-subset(toptableIQR_control, 
                              toptableIQR_control$adj.P.Val<=0.05)
dim(Control.fdr.005.table)
summary(Control.fdr.005.table) ##  Check the maximum adj.P.val is < 0.05
```


Hemos pasado de 54675 genes iniciales a 27335 tras el filtro IR y, finalmente,
a 20612 genes tras el filtro de FDR. 


## Incorporación de los nombres de los genes

Queremos incorporar anotaciones a *Control.fdr.005.table*

```{r, message=FALSE, results=FALSE, warning=FALSE}
library("hgu133plus2.db")
```

```{r}
# Recuperamos los nombres de las sondas de los diferentes spots del microarray
Control_probenames.fdr.005<-as.character(rownames(Control.fdr.005.table))
head(Control_probenames.fdr.005)

# Recuperamos la lista de genes asociados a las diferentes sondas del microarray
Control_list.GeneSymbol.fdr.005<-mget(Control_probenames.fdr.005, hgu133plus2SYMBOL)
head(Control_list.GeneSymbol.fdr.005)

# ahora mostrmos solo los nombres de los genes
Control_char.GeneSymbol.fdr.005<- as.character(Control_list.GeneSymbol.fdr.005)
head(Control_char.GeneSymbol.fdr.005)

# Añadimos al data frame la columna con los nombres de los genes
Control_toptable.annotated<-cbind(Control.fdr.005.table, Control_char.GeneSymbol.fdr.005)
head(Control_toptable.annotated)
```

Reordenamos las columnas colocando la nueva columna con los nombres de los genes en primer lugar

```{r}
# Change name column added
colnames(Control_toptable.annotated)[length(colnames(Control_toptable.annotated))] <- "Gene_Name"

# Get column names
colnames(Control_toptable.annotated)

# Reordering colnumns by positions. We want "Gene_names" as the second column

Control_toptable.annotated<- Control_toptable.annotated[, c("Gene_Name", "logFC", "AveExpr", "t", "P.Value", "adj.P.Val", "B")]
head(Control_toptable.annotated)
  
```


Links utilizados:

* https://bioconductor.org/packages/release/bioc/vignettes/AnnotationDbi/inst/doc/IntroToAnnotationPackages.pdf

* https://bioconductor.org/packages/devel/bioc/manuals/AnnotationDbi/man/AnnotationDbi.pdf

```{r}
library("hgu133plus2.db")

# Recuperamos los nombres de las sondas de los diferentes spots del microarray
Control_probenames.fdr.005<-as.character(rownames(Control.fdr.005.table))
head(Control_probenames.fdr.005)

# Recuperamos los nombres de los genes y las rutas asociadas a las diferentes sondas del microarray
Control_list.PATH.fdr.005<-mget(Control_probenames.fdr.005, hgu133plus2PATH)
Control_list.GeneSymbol.fdr.005<-mget(Control_probenames.fdr.005, hgu133plus2SYMBOL)

# ahora mostrmos solo los nombres de los genes
Control_char.PATH.fdr.005 <- as.character(Control_list.PATH.fdr.005)
Control_char.GeneSymbol.fdr.005 <- as.character(Control_list.GeneSymbol.fdr.005)

# Añadimos al data frame la columna con los nombres de los genes
Control_toptable.annotated<-cbind(Control.fdr.005.table, Control_char.GeneSymbol.fdr.005, Control_char.PATH.fdr.005 )
head(Control_toptable.annotated)

```

He comprobado que puedo  incorporar más información si sigo un método alternativo
explicado en la viñeta de [*AnnotationDb*] (https://bioconductor.org/packages/devel/bioc/manuals/AnnotationDbi/man/AnnotationDbi.pdf) 

```{r, warning = FALSE}

# Using the aternatively method
# if you wanted to extract only one column of data you could instead use themapIds method
Control_list.GeneSymbol_2 <- as.list(mapIds(hgu133plus2.db, keys=Control_probenames.fdr.005, column="SYMBOL", keytype = "PROBEID"))

# see the annotation obtained from this spot in both methods
spot <- "216191_s_at" 
Control_list.GeneSymbol.fdr.005[spot] # return NA
Control_list.GeneSymbol_2[spot] # return YME1L1

# The second method retrieve more information
unlist(head(Control_list.GeneSymbol.fdr.005))
unlist(head(Control_list.GeneSymbol_2))

# Let's see the amount of NA in each method
sum(is.na(Control_list.GeneSymbol.fdr.005)) # 3647
sum(is.na(Control_list.GeneSymbol_2)) # 2633

```

Obtenemos las anotaciones y preparamos los data frame para la unión. 

```{r, warning=FALSE}


# hgu133plus2()

# Here we can see the different keytypes available
# keytypes(hgu133plus2.db)

# Here we check which keytype should be use
# head(keys(hgu133plus2.db, keytype = "PROBEID"))

# if we have some keys, we can use selectto extract them
# Get the official gene symbol (HGNC) --> SYMBOL
# Get the associated gene description --> GENENAME
# Get the Gene Ontology terms --> GO
# Get the associated KEGG pathways --> PATH
Control_annotations <- as.data.frame(select(hgu133plus2.db, keys=Control_probenames.fdr.005, 
            columns=c("SYMBOL", "GENENAME", "GO",  "PATH"), 
            keytype="PROBEID"))

# Take the original table with values Create a new key column with spots id
Control.fdr.005.table$PROBEID <- rownames(Control.fdr.005.table) 

# Explore their content
head(Control_annotations)
head(Control.fdr.005.table)
```

Ahora unimos el data frame original con los niveles de expresión (*Control.fdr.005.table*)
con el data frame con las anotaciones (*Control_annotations*)

```{r}
# An outer join. Returns all rows from both data frame, join records from 
# the left which have matching keys (PROBEID) in the right table.
Control_merged_fdr_annotations <- merge(Control.fdr.005.table, Control_annotations,
                                        by = "PROBEID", all = TRUE)

# Check we have not lose any spot
length(unique(Control_merged_fdr_annotations$PROBEID)) == dim(Control.fdr.005.table)[1]
```

```{r save-as-xlsx}
if(!require("xlsx")){
    install.packages("xlsx")}

library("xlsx")

# write.xlsx(Control_merged_fdr_annotations, file = "Resultado.xlsx")
```







# Lineas celulares estudiadas por separado

## Línea celular KOPT-K1

Los ficheros control son:

* KOPT-K1_DMSO $\rightarrow$ "GSM455115.CEL", "GSM455116.CEL", "GSM455117.CEL"

* KOPT-K1_SAHM1 $\rightarrow$ "GSM455121.CEL", "GSM455122.CEL", "GSM455123.CEL"


### Cargamos los ficheros .CEL y extraemos el raw data

```{r cargamos-ficheros-CEL-KOPT, warning=FALSE}

# Read .CEL files 
# data <- ReadAffy(filenames=targets$FileName)
CELfiles_KOPT <- c("GSM455115.CEL", "GSM455116.CEL", "GSM455117.CEL", "GSM455121.CEL", "GSM455122.CEL", "GSM455123.CEL")

rawdata_KOPT <- ReadAffy(filenames = CELfiles_KOPT)
rawdata_KOPT
```

###  Análisis exploratorio de la calidad de los datos iniciales

#### Distribución de las intensidades antes de normalizar

```{r Distribucion-intensidades-KOPT, message = FALSE, warning=FALSE}
#########################
# Intensity distributions
#########################

# Show intensity distributrions with hist function 
hist(rawdata_KOPT, lty = rep(1, length(CELfiles_KOPT)), col = mycols,
   main = "Intensity distributions KOPT-K1 Before Normalization")

# Add legend in the top right corner 
legend("topright", rownames(pData(rawdata_KOPT)),
       lty = rep(1, length(CELfiles_KOPT)), 
       col = mycols,
       cex = 1)

# Tema 19 página 637. Vemos que no hay problemas y que no tenemos que descartar
# ningún array, aunque sí es importante normalizar. No hay ninguno con un valor
# muy alto en log intensity. También vemos que todos tienen una distribución 
# más o menos igual. 
```

#### Boxplot antes de normalizar

```{r KOPT-boxplot_no_normalizado}
#############################
# boxplot antes de normalizar
#############################

boxplot(rawdata_KOPT,
        main="Boxplot KOPT-K1 Before Normalization",
        col = mycols,
        names = sampleNames(rawdata_KOPT),
        las = 2,  # vertical labels
        cex.axis = 0.6, # size labels
        yaxt = "n") # do not show y labels
axis(2, cex.axis = 1) # plot y labels with higher size
```



## Normalización con RMA

```{r Normalizacion-RMA-KOPT}
#4. Normalize with RMA 
#generates object eset (class ExprSet), 
#expresso function provides intensities in log scale
eset_KOPT <- expresso(rawdata_KOPT,
                 bg.correct = TRUE, 
                 bgcorrect.method="rma", # corregir fondo
                 normalize = TRUE, 
                 normalize.method="quantiles", 
                 pmcorrect.method="pmonly", # los que machean perfectamente
                 summary.method="medianpolish", # resumeme por la mediana par aun mismo gen
                 verbose = TRUE,
) 
```

### Distribución de la intensidad tras la normalización 

```{r KOPT-intensity-normalizado, message = FALSE}
#########################
# Intensity distributions
#########################

# Show intensity distributrions
exprseset_KOPT <- as.data.frame(exprs(eset_KOPT)) # cojo las intensidades normalizadas
dens_KOPT <- apply(data.frame(exprseset_KOPT), 2, density)

plot(NA, xlim=range(sapply(dens_KOPT, "[", "x")), ylim=range(sapply(dens_KOPT, "[", "y")),
     main = "Intensity distributions KOPT-K1 After Normalization",
     xlab = "log intensity", ylab = "density")
distribution_KOPT <- mapply(lines, dens_KOPT, 
                            col=c(rep(mycols[1], 3), rep(mycols[4], 3)), lwd = 1)

# Add legend in the top right corner
legend("topright", legend=names(dens_KOPT), lty = rep(1, length(CELfiles_KOPT)), col = mycols, cex = 1)
```

### Boxplots tras la normalización

```{r KOPT-boxplot-normalizado}
# boxplot de todos los genes después de normalizar
boxplot(data.frame(exprseset_KOPT),
        main="Boxplot KOPT-K1 After Normalization (log scale)",
        col = mycols,
        names = sampleNames(rawdata_KOPT),
        las = 2,  # vertical labels
        cex.axis = 0.6, # size labels
        yaxt = "n") # do not show y labels
axis(2, cex.axis = 1) # plot y labels with higher size
```



### Filtro del rango intercuartílico

```{r KOPT-K1-IQR}
# boxplot de solo los genes normalizados con un ranog intercuartílico superior a 0.5 para que tengan variabilidad
esetIQR_KOPT <- varFilter(eset_KOPT, var.func=IQR, var.cutoff=0.5, filterByQuantile=TRUE)

## Comprobamos el filtro del rango intercuartílico
dim(exprs(eset_KOPT))
dim(exprs(esetIQR_KOPT))



# boxplot de solo los genes normalizados con un ranog intercuartílico superior a 0.5 para que tengan variabilidad
exprsesetIQR_KOPT <- as.data.frame(exprs(esetIQR_KOPT))

boxplot(data.frame(exprsesetIQR_KOPT),
        main="Boxplot KOPT-K1 After Normalization and IQR filter (log scale)",
        col = mycols,
        names = sampleNames(rawdata_KOPT),
        las = 2,  # vertical labels
        cex.axis = 0.6, # size labels
        yaxt = "n") # do not show y labels
axis(2, cex.axis = 1) # plot y labels with higher size
```


## Línea celular HPB-ALL

* HPB-ALL_DMSO $\rightarrow$ "GSM455118.CEL", "GSM455119.CEL", "GSM455120.CEL"

* HPB-ALL_SAHM1 $\rightarrow$ "GSM455124.CEL", "GSM455125.CEL", "GSM455126.CEL"

## Cargamos los ficheros .CEL y extraemos el raw data

```{r cargamos-ficheros-CEL-HPB, warning=FALSE}

# Read .CEL files 
# data <- ReadAffy(filenames=targets$FileName)
CELfiles_HPB <- c("GSM455118.CEL", "GSM455119.CEL", "GSM455120.CEL", "GSM455124.CEL", "GSM455125.CEL", "GSM455126.CEL")

rawdata_HPB <- ReadAffy(filenames = CELfiles_HPB)
rawdata_HPB
```

##  Análisis exploratorio de la calidad de los datos iniciales

### Distribución de las intensidades antes de normalizar

```{r Distribucion-intensidades-HPB, message = FALSE, warning=FALSE}
#########################
# Intensity distributions
#########################

# Show intensity distributrions with hist function 
hist(rawdata_HPB, lty = rep(1, length(CELfiles_KOPT)), col = mycols,
   main = "Intensity distributions HPB-ALL Before Normalization")

# Add legend in the top right corner 
legend("topright", rownames(pData(rawdata_HPB)),
       lty = rep(1, length(CELfiles_HPB)), 
       col = mycols,
       cex = 1)

# Tema 19 página 637. Vemos que no hay problemas y que no tenemos que descartar
# ningún array, aunque sí es importante normalizar. No hay ninguno con un valor
# muy alto en log intensity. También vemos que todos tienen una distribución 
# más o menos igual. 
```

### Boxplot antes de normalizar

```{r boxplot-HPB_no-normalizado}
#############################
# boxplot antes de normalizar
#############################

boxplot(rawdata_HPB,
        main="Boxplot HPB-ALL Before Normalization",
        col = mycols,
        names = sampleNames(rawdata_HPB),
        las = 2,  # vertical labels
        cex.axis = 0.6, # size labels
        yaxt = "n") # do not show y labels
axis(2, cex.axis = 1) # plot y labels with higher size
```

## Ver distintos procesos de Normalizacióm

## Normalización con RMA

```{r Normalizacion-RMA-HPB}
#4. Normalize with RMA 
#generates object eset (class ExprSet), 
#expresso function provides intensities in log scale
eset_HPB <- expresso(rawdata_HPB,
                 bg.correct = TRUE, 
                 bgcorrect.method="rma", # corregir fondo
                 normalize = TRUE, 
                 normalize.method="quantiles", 
                 pmcorrect.method="pmonly", # los que machean perfectamente
                 summary.method="medianpolish", # resumeme por la mediana par aun mismo gen
                 verbose = TRUE,
) 
```

### Distribución de la intensidad tras la normalización 

```{r HPB-intensity-normalizado, message = FALSE}
#########################
# Intensity distributions
#########################

# Show intensity distributrions
exprseset_HPB <- as.data.frame(exprs(eset_HPB)) # cojo las intensidades normalizadas
dens_HPB <- apply(data.frame(exprseset_HPB), 2, density)

plot(NA, xlim=range(sapply(dens_HPB, "[", "x")), ylim=range(sapply(dens_HPB, "[", "y")),
     main = "Intensity distributions HPB-ALL After Normalization",
     xlab = "log intensity", ylab = "density")
distribution_HPB <- mapply(lines, dens_HPB, col=c(rep(mycols[1], 3), rep(mycols[4], 3)), lwd = 1)

# Add legend in the top right corner
legend("topright", legend=names(dens_HPB), lty = rep(1, length(CELfiles_HPB)), col = mycols, cex = 1)
```

### Boxplots tras la normalización

```{r HPB-boxplot-normalizado}
# boxplot de todos los genes después de normalizar
boxplot(data.frame(exprseset_HPB),
        main="Boxplot HPB-ALL After Normalization (log scale)",
        col = mycols,
        names = sampleNames(rawdata_HPB),
        las = 2,  # vertical labels
        cex.axis = 0.6, # size labels
        yaxt = "n") # do not show y labels
axis(2, cex.axis = 1) # plot y labels with higher size
```

### Filtro del rango intercuartílico

```{r HPB-K1-IQR}
# boxplot de solo los genes normalizados con un ranog intercuartílico superior a 0.5 para que tengan variabilidad
esetIQR_HPB <- varFilter(eset_HPB, var.func=IQR, var.cutoff=0.5, filterByQuantile=TRUE)

## Comprobamos el filtro del rango intercuartílico
dim(exprs(eset_HPB))
dim(exprs(esetIQR_HPB))



# boxplot de solo los genes normalizados con un ranog intercuartílico superior a 0.5 para que tengan variabilidad
exprsesetIQR_HPB <- as.data.frame(exprs(esetIQR_HPB))

boxplot(data.frame(exprsesetIQR_HPB),
        main="Boxplot HPB-ALL After Normalization and IQR filter (log scale)",
        col = mycols,
        names = sampleNames(rawdata_HPB),
        las = 2,  # vertical labels
        cex.axis = 0.6, # size labels
        yaxt = "n") # do not show y labels
axis(2, cex.axis = 1) # plot y labels with higher size
```
Curiosamente el número de muestras que se eliminan tras normalizar en ambos tipos
celulares es 27337. 

## Expresión diferencial


## Filtro por FDR < 0.05 para quedarme con los genes significativos



## Incorporación de los nombres de los genes SYMBOL

## GSEA





